---
# Front matter
lang: ru-RU
title: "Отчет по Лабораторной Работе № 1"
subtitle: "Работа с git"
author: "Нзита Диатезилуа Катенди"

# Formatting
toc-title: "Содержание"
toc: true # Table of contents
toc_depth: 2
lof: true # List of figures
fontsize: 12pt
linestretch: 1.5
papersize: a4paper
documentclass: scrreprt
polyglossia-lang: russian
polyglossia-otherlangs: english
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase
indent: true
pdf-engine: lualatex
header-includes:
  - \linepenalty=10 # the penalty added to the badness of each line within a paragraph (no associated penalty node) Increasing the υalue makes tex try to haυe fewer lines in the paragraph.
  - \interlinepenalty=0 # υalue of the penalty (node) added after each line of a paragraph.
  - \hyphenpenalty=50 # the penalty for line breaking at an automatically inserted hyphen
  - \exhyphenpenalty=50 # the penalty for line breaking at an explicit hyphen
  - \binoppenalty=700 # the penalty for breaking a line at a binary operator
  - \relpenalty=500 # the penalty for breaking a line at a relation
  - \clubpenalty=150 # extra penalty for breaking after first line of a paragraph
  - \widowpenalty=150 # extra penalty for breaking before last line of a paragraph
  - \displaywidowpenalty=50 # extra penalty for breaking before last line before a display math
  - \brokenpenalty=100 # extra penalty for page breaking after a hyphenated line
  - \predisplaypenalty=10000 # penalty for breaking before a display
  - \postdisplaypenalty=0 # penalty for breaking after a display
  - \floatingpenalty = 20000 # penalty for splitting an insertion (can only be split footnote in standard LaTeX)
  - \raggedbottom # or \flushbottom
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Приобретение практических навыков работы с ситемой управления версиями Git.

# Задание

Провести базовую настройку гит, создать проект и, используя его, изучить основные действия с репозиторием.

# Теоретическое введение

Git — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года; координатор — Дзюн Хамано [@wiki:bash].

Работа выполнена с помощью веб-сервиса GitHub [@git:bash].

# Выполнение лабораторной работы

## Подготовка

Сначала настроим core.autocrlf с параметрами true и input, чтобы сделать все переводы строк текстовых файлов в главном репозитории одинаковыми, а затем настроим отображение unicode(рис. @fig:001).

![Настройка git](image/image1.png){#fig:001 width=70%}

## Создание проекта

Создадим пустой каталог hello, а в нём файл с именем hello.html. Затем создадим  git репозиторий из этого каталога, выполнив команду git init. Добавим файл в репозиторий и проверим статус, который сообщает, что коммитить нечего(рис. @fig:002).

![Создание репозитория](image/image2.png){#fig:002 width=70%}

## Внесение изменений

Изменим содержимое файла hello.html на:
```
<h1>Hello, World!</h1>
```

Проверив состояние рабочего каталога увидим, что git знает, что файл hello.html был изменен, но при этом эти изменения еще не зафиксированы в репозитории. Теперь проиндексируем изменения и снова посмотрим статус, в нём указано, что изменения пока не записаны в резапозиторий. И наконец закоммитим изменения, внеся их в репозиторий и снова посмотрим статус, который теперь показывает, что все изменения внесены в репозиторий (рис. @fig:003).

![Внесение изменений в содержимое репозитория](image/image3.png){#fig:003 width=70%}

Изменим страницу «Hello, World», чтобы она содержала стандартные теги <html>
и <body>.
```
<html>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```
Теперь добавим это изменение в индекс git и добавим заголовки HTML (секцию <head>) к странице «Hello, World». Проверив текущий статус увидим, что hello.html указан дважды в состоянии. Первое изменение (добавление стандартных тегов) проиндексировано и готово к коммиту. Второе изменение (добавление заголовков HTML) является непроиндексированным. Произведем коммит проиндексированного изменения, затем проиндексируем оставшееся изменение, посмотрим статус и прокоммитим его(рис. @fig:004).

![Внесение нескольких изменений в содержимое репозитория](image/image4.png){#fig:004 width=70%}

## История

Посмотрим список произведённыз изменений в станлартном виде, затем в однострочном, а также с указанием времени и количества(рис. @fig:005).

![Просмотр истории](image/image5.png){#fig:005 width=70%}

## Получение старых версий

Изучим данные лога и найдем там хэш первого коммита, используя его вернемся к первой верссии и просмотрим файл hello.html, действительно, увидим первую версию. Затем вернемся к последней версии в ветке master и вновь посмотрим на файл(рис. @fig:006).

![Просмотр разных версий репозитория](image/image6.png){#fig:006 width=70%}

## Создание тегов версий

Назовем текущую версию страницы hello первой (v1). Создадим тег первой версии и используем его для того чтобы венуться к предыдущей, которой также присвоим тег(рис. @fig:007).

![Создание тегов версий](image/image7.png){#fig:007 width=70%}

Переключимся по тегам между двумя отмеченными версиями. Просмотрим все доступные теги(их два) и посмотрим теки в логе(рис. @fig:008).

![Переключение по имени тега и просмотр доступных тегов](image/image8.png){#fig:008 width=70%}

## Отмена локальных изменений (до индексации)

Убдеимся, что мы находимся на последнем коммите ветки master и внесем изменение в файл hello.html в виде нежелательного комментария.  Затем проверим статус, увидим, что изменения ещё не проиндексированы. Используем команду git checkout для переключения версии файла hello.html в репозитории(рис. @fig:009).

![Отмена локальных изменений (до индексации)](image/image9.png){#fig:009 width=70%}

## Отмена проиндексированных изменений (перед коммитом)


Внесем изменение в файл hello.html в виде нежелательного комментария
```
<html>
  <head>
    <!-- This is an unwanted but staged comment -->
  </head>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```
Проиндексируем это изменение и проверим состояние. Состояние показывает, что изменение было проиндексировано и готово к коммиту. Используем команду git reset, чтобы сбросить буферную зону к HEAD. Это очищает буферную зону от изменений, которые мы только что проиндексировали. И переключимся на последнюю версию коммита, посмотрев статус увидим, что наш каталог опять чист(рис. @fig:010).

![Отмена проиндексированных изменений (перед коммитом)](image/image10.png){#fig:010 width=70%}

## Отмена коммитов

Изменим файл hello.html на следующий.

```
<html>
  <head>
  </head>
  <body>
    <h1>Hello, World!</h1>
    <!-- This is an unwanted but committed change -->
  </body>
</html>
```
Проиндексируем изменения файла и прокоммитим их. Чтобы отменить коммит, нам необходимо сделать коммит, который удаляет изменения, сохраненные нежелательным коммитом. Перейдем в редактор, где изменим нежелательный коммит. Проверим лог. Проверка лога показывает нежелательные и отмененные коммиты в наш репозиторий(рис. @fig:011).

![Отмена коммитов](image/image11.png){#fig:011 width=70%}

## Удаление коммиттов из ветки

Удалим последние два коммита с помощью сброса, сначала отметим последний коммит тегом, чтобы его можно было потом найти. Используем команду git reset, чтобы вернуться к версии до этих коммитов. Теперь в логе их нет, но если посмотреть логи с опцией  --all можно всё ещё их увидеть, но метка HEAD находится на нужной нам версии(рис. @fig:012).

![Удаление коммиттов из ветки](image/image12.png){#fig:012 width=70%}

## Удаление тега oops

Удалим тег oops и коммиты, на которые он ссылался, сборщиком мусора. Теперь этот тег не отображается в репозитории(рис. @fig:013).

![Удаление тега oops](image/image13.png){#fig:013 width=70%}

## Изменение предыдущего коммита

Добавим в страницу комментарий автора.
```
<!-- Author: Dmitry S. Kulyabov -->
<html>
  <head>
  </head>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```
Затем добавим их в репозиторий. Теперь мы хотим добавить в комментарий автора почту, обноим страницу hello, включив в неё почту. Чтобы у нас остался один коммит, а не два, изменим последний с помощьб опции --amend, теперь в логах отображается последняя версия коммита(рис. @fig:014).

![Изменение предыдущего коммита](image/image14.png){#fig:014 width=70%}

## Перемещение файлов

Переместим наш файл в каталог lib. Для этого создадим его и используем команду git mv, сделаем коммит этого пермещения(рис. @fig:015).

![Перемещение файлов](image/image15.png){#fig:015 width=70%}

## Подробнее о структуре

Добавим файл index.html в наш репозиторий
```
<html>
  <body>
    <iframe src="lib/hello.html" width="200" height="200" />
  </body>
</html>
```
Добавим файл и сделаем коммит(рис. @fig:016).

![Добавление нового файла в репозиторий](image/image16.png){#fig:016 width=70%}

Теперь при открытии index.html, увидим кусок страницы hello в маленьком окошке(рис. @fig:017).

![Добавление нового файла в репозиторий](image/image17.png){#fig:017 width=70%}

## Git внутри: Каталог .git

Просмотрим каталог, в котором хранится вся информация git. Затем посмотрим набор каталогов, имена которых состоят из 2 символов. Имена каталогов являются первыми двумя буквами хэша sha1 объекта, хранящегося в git. Посмотрим в один из каталогов с именем из 2 букв. Увидим файлы с именами из 38 символов. Это файлы, содержащие объекты, хранящиеся в git. Посмотрим файл конфигурации, создающийся для каждого конкретного проекта. Затем посмотрим подкаталоги .git/refs/heads и .git/refs/tags, а также содержимое файла v1, в нём хранится хэш коммита, привязанный к тегу. Также посмотрим содержимоей файла HEAD, который содержит ссылку на текущую ветку, в данный момент это ветка master(рис. @fig:018).

![Каталог .git](image/image18.png){#fig:018 width=70%}

## Работа непосредственно с объектами git

Найдем последний коммит и выедем его с помощью  SHA1 хэша. Затем посмотрим дерево каталогов, ссылка на который идёт в последнем коммите, вывдем каталог lib и файл  hello.html(рис. @fig:019).

![Работа непосредственно с объектами git](image/image19.png){#fig:019 width=70%}

Исследуем  git репозиторий вручную самостоятельно. Используя хэш родительского коммита последовательно дойдем до первой версии файла hello.html и посмотрим его(рис. @fig:020).

![Поиск оригинального файла hello.html](image/image20.png){#fig:020 width=70%}

## Создание ветки

Создадим новую ветку «style» и перейдем в неё. Добавим туда файл стилей style.css и добавим его в репозиторий. Обновим файл hello.html, чтобы использовать стили style.css и index.html, также обавим их в репозиторий(рис. @fig:021).

![Создание ветки](image/image21.png){#fig:021 width=70%}

## Навигация по веткам

Посмотрим все логи(рис. @fig:022).

![Просмотр логов новой ветки](image/image22.png){#fig:022 width=70%}

Переключимся обратно на основную ветку и просмотрим содержимое файла ib/hello.html, заметим, что он не использует стили, также просмотрим содержимое этого файла в новой ветке(рис. @fig:023).

![Переключение между ветками](image/image23.png){#fig:023 width=70%}

## Изменения в ветке master

Вернемся в основную ветку и добавим файл  README.md. Просмотрим ветки и их различия(рис. @fig:024, @fig:025).

![Изменения в ветке master](image/image24.png){#fig:024 width=70%}

![Просмотр веток](image/image25.png){#fig:025 width=70%}


## Слияние

Слияние переносит изменения из двух веток в одну. Вернемся к ветке style и сольем master с style(рис. @fig:026).

![Слияние веток](image/image26.png){#fig:026 width=70%}

## Создание конфликта

Вернемся в ветку master и создадим конфликт, внеся изменения в файл hello.html. Просмотрим ветки. После коммита «Added README» ветка master была объединена с веткой style, но в настоящее время в master есть дополнительный коммит, который не был слит с style. Последнее изменение в master конфликтует с некоторыми изменениями в style(рис. @fig:027).

![Создание конфликта](image/image27.png){#fig:027 width=70%}

## Разрешение конфликтов

Вернемся к ветке style и попытаемся объединить ее с новой веткой
master. В файле lib/hello.html можно увидеть записи с обеих версий этого файла. Первый раздел — версия текущей ветки (style). Второй раздел — версия ветки master.  Внесем изменения в lib/hello.html, оставив только необходимую нам запись и добавим этот файл в репозиторий, чтобы вручную разрешить конфликт(рис. @fig:028).

![Разрешение конфликта](image/image28.png){#fig:028 width=70%}

## Сброс ветки style

Вернемся на ветке style к точке перед тем, как мы слили ее с веткой master. Мы хотим вернуться в ветке style в точку перед слиянием с master. Нам необходимо найти последний коммит перед слиянием(рис. @fig:029).

![Поиск коммита перед слиянием](image/image29.png){#fig:029 width=70%}

Мы видим, что коммит «Updated index.html» был последним на ветке style
перед слиянием. Сбросим ветку style к этому коммиту(рис. @fig:030).

![Сброс ветки style](image/image30.png){#fig:030 width=70%}

Поищим лог ветки style. Увидим, что у нас в истории больше нет коммитов слияний.

## Сброс ветки master

Добавив интерактивный режим в ветку master, мы внесли изменения, конфликтующие с изменениями в ветке style. Давайте вернемся в ветке master в точку перед внесением конфликтующих изменений. Это позволяет нам продемонстрировать работу команды git rebase, не беспокоясь о конфликтах. Просмотрим коммиты ветки master(рис. @fig:031).

![Поиск коммита перед конфликтом](image/image31.png){#fig:033 width=70%}

Коммит «Added README» идет непосредственно перед коммитом конфликтующего интерактивного режима. Мы сбросим ветку master к коммиту «Added README»(рис. @fig:032).

![Сброс ветки master](image/image32.png){#fig:032 width=70%}

## Перебазирование

Используем команду rebase вместо команды merge. Мы вернулись в точку до первого слияния и хотим перенести изменения из ветки master в нашу ветку style. На этот раз для переноса изменений из ветки master мы будем использовать команду git rebase вместо слияния(рис. @fig:033).

![Перебазирование](image/image33.png){#fig:033 width=70%}

## Слияние в ветку master
 
Вернемся в ветку master и сольем ветку style в неё с помощью команды git merge(рис. @fig:034).

![Слияние style в master](image/image34.png){#fig:034 width=70%}

## Клонирование репозиториев

Перейдем в наш рабочий каталог и сделаем клон репозитория hello, затем создадим клон репозитория. Просмотрев его увидим список всех файлов на верхнем уровне оригинального репозитория README.md, index.html и lib. Затем просмотрим историю репозитория и увидим список всех коммитов в новый репозиторий, и он совпадает с историей коммитов в оригинальном репозитории. Единствен в названиях веток(рис. @fig:035).

![Клонирование репозиториев](image/image35.png){#fig:035 width=70%}

## Что такое origin?


Клонированный репозиторий знает об имени по умолчанию удаленного репозитория. Посмотрим, подробную информацию об имени по умолчанию.Для того, чтобы увидеть все ветки используем опцию -a(рис. @fig:036).

![Просмотр имени по умолчанию удаленного репозитория](image/image36.png){#fig:036 width=70%}

## Удаленные ветки

Посмотрим на ветки, доступные в нашем клонированном репозитории. Можно увидеть, что в списке только ветка master(рис. @fig:037).

![Просмтр доступных веток](image/image37.png){#fig:037 width=70%}

## Изменение оригинального репозитория

Перейдем в репозиторий hello. Внесем изменения в файл README.md. Затем добавим их в репозиторий(рис. @fig:038).

![Изменение оригинального репозитория](image/image38.png){#fig:038 width=70%}

Перейдём в клон репозитория и используем команду git fetch, которая будет извлекать новые коммиты из удаленного репозитория, но не будет сливать их с наработками в локальных ветках(рис. @fig:039).

![Извлечение изменений](image/image39.png){#fig:039 width=70%}

## Слияние извлеченных изменений

Сольем внесённые изменения в главную ветку. Также можно было бы использовать команду git pull, которая является объединением fetch и merge в одну команду.

(рис. @fig:040).

![Слияние извлеченных изменений](image/image40.png){#fig:040 width=70%}

## Добавление ветки наблюдения

Добавим локальную ветку, которая отслеживает удаленную ветку, теперь мы можем видеть ветку style в списке веток и логе(рис. @fig:041).

![Добавление ветки наблюдения](image/image41.png){#fig:041 width=70%}

## Создание чистого репозитория

Как правило, репозитории, оканчивающиеся на .git являются чистыми репозиториями. Создадим такой в рабочем каталоге. Затем добавим репозиторий  hello.git к нашему оригинальному репозиторию(рис. @fig:042).

![Создание чистого репозитория](image/image42.png){#fig:042 width=70%}

## Отправка и извлечение изменений 

Так как чистые репозитории, как правило, расшариваются на каком-нибудь сетевом сервере, нам необходимо отправить наши изменения в другие репозитории. Начнем с создания изменения для отправки. Отредактируем файл README.md и сделаем коммит, затем отправим изменения в общий репозиторий. Затем извлечем изменения из общего репозитория(рис. @fig:043).

![Отправка и извлечение изменений](image/image43.png){#fig:043 width=70%}

# Выводы

В результаты выполнение лабораторной работы были приобретены практические навыки работы с ситемой управления версиями Git.

# Список литературы{.unnumbered}

::: {#refs}
:::
